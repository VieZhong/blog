---
layout: post
title: 利用移动端HTML的touch事件实现相册展示、图片滑动查看
author: 小夫
summary: 该篇文章，提供了一个制作相册的例子，可以在移动端浏览器中使用。效果跟新浪微博和微信朋友圈查看图片一样，点击图片全屏查看，左右滑动可查看前一张或后一张图片，同时可支持查看长图片。滑动主要利用了touchstart、touchmove、touchend事件实现的。
---
<div class="post-content">
	<div class="post-content-block-1">
		<div class="post-content-block-2">
			<div class="post-content-body-default">
				话不多说，先看HTML代码架构。<br>
				<pre>
&lt;div class="layer bottomLayer"&gt;
    &lt;div class="sImgContainer"&gt;
        &lt;div&gt;&lt;img src="images/try0.jpg"&gt;&lt;/div&gt;
        &lt;div&gt;&lt;img src="images/try1.jpg"&gt;&lt;/div&gt;
        &lt;div&gt;&lt;img src="images/try2.jpg"&gt;&lt;/div&gt;
        &lt;div&gt;&lt;img src="images/try3.jpg"&gt;&lt;/div&gt;
        &lt;div&gt;&lt;img src="images/try4.jpg"&gt;&lt;/div&gt;
        &lt;div&gt;&lt;img src="images/try5.jpg"&gt;&lt;/div&gt;
        &lt;div&gt;&lt;img src="images/try6.jpg"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class="layer transparentLayer"&gt;&lt;/div&gt;
&lt;div class="layer overLayer"&gt;
    &lt;div id="lImgContainer"&gt;&lt;/div&gt;
&lt;/div&gt;
				</pre><br>
				样式为：<br>
				<pre>
.layer{
    position: fixed;
    top: 0;
    left: 0;
}

.bottomLayer{
    background: #CEC;
}

.transparentLayer{
    background: opacity: 0;
    display: none;
}

.overLayer{
    background: #000;
    overflow: hidden;
    display: none;
}

.sImgContainer{
    margin-top: 180px;
}

.sImgContainer div{
    display: inline-block;
    margin-left: 10px;
    margin-bottom: 14px;
    width: 100px;
    max-height: 140px;
    overflow: hidden;
}

.sImgContainer img{           
    width: 100%;
}
				</pre>
				可以看到，我先把页面分成三层，每一层都把positon成fixed，使layer脱离文档流，实现逐层覆盖。第一层是底层，用于展示图片缩略图。第二层为透明层，该层作用后面会提到。第三层是大图片展示层，背景为黑色。<br><br>
				我们先看第一层，即底层。底层通过sImgContainer放置图片，但为了解决长图片缩略图不超出div块的范围，必须设置overflow为hidden，即超出部分的内容不展示。<br>
				接着，是第二层，我把它的背景设置为透明，主要是为了让用户不感到它的存在。但它的存在必不可少，这是因为，如果没有该层，点击查看底层图片之后，在点击屏幕隐藏大图片时，大图片层消失后手指还在屏幕上少许抖动以致再次触发底层图片的click事件。现在加上透明层，可以隔绝两者，防止手指抖动误点。我们只需要让该透明层在大图片层隐藏后的一段时间后再隐藏，比如300ms，这样即使用户点击大图片消失时，防止手指抖动触发底层图片了。<br><br>
				现在，重点来了。
			</div>
		</div>
		<div class="post-content-title-1">重点是第三层——查看大图片</div>
		<div class="post-content-block-2">	
			<div class="post-content-title-2">display:block</div>
			<div class="post-content-body-default">
			1. block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。<br>
			2. block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。<br>
			3. block元素可以设置margin和padding属性。
			</div>

			<div class="post-content-title-2 post-content-vmargin-2">display:inline</div>
			<div class="post-content-body-default">
			1. inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。<br>
			2. inline元素设置width,height属性无效。<br>
			3. inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。
			</div>

			<div class="post-content-title-2 post-content-vmargin-2">display:inline-block</div>
			<div class="post-content-body-default">
			1. 简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。
			</div>
		</div>
	</div>

	<div class="post-content-block-1 post-content-vmargin-1">
		<div class="post-content-title-1">inline-block的对齐方式</div>
		<div class="post-content-body-default">
			模型如下：<br>
			<pre>
&lt;style type="text/css"&gt;
    .outerdiv{
        width: 280px;
        background-color: #F00;
    }
    .innerdiv1{
        display: inline-block;
        background-color: #0F0;
        width: 120px;
        height: 100px;
        vertical-align: inherit;
    }
    .innerdiv2{
        display: inline-block;
        background-color: #00F;
        width: 120px;
        height: 180px;
        vertical-align: inherit;
    }
&lt;/style&gt;			
&lt;div class="outerdiv"&gt;
    &lt;div class="innerdiv1"&gt;A&lt;/div&gt;
    &lt;div class="innerdiv2"&gt;B&lt;/div&gt;
&lt;/div&gt;
			</pre>
		</div>
		<div class="post-content-block-2">	
			<div class="post-content-title-2">vertical-align:middle</div>
			<div class="post-content-body-default">
				两元素的中间对齐：<br>
				&nbsp;设置类.innerdiv1和类.innerdiv2的style属性vertical-align为middle，<br>
				效果如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<img src="{{site.baseurl}}/img/2015-12-17/vertical-middle.png">
			</div>

			<div class="post-content-title-2 post-content-vmargin-2">vertical-align:top</div>
			<div class="post-content-body-default">
				两元素的顶部对齐：<br>
				&nbsp;设置类.innerdiv1和类.innerdiv2的style属性vertical-align为top，<br>
				效果如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<img src="{{site.baseurl}}/img/2015-12-17/vertical-top.png">
			</div>

			<div class="post-content-title-2 post-content-vmargin-2">vertical-align:bottom</div>
			<div class="post-content-body-default">
				两元素的底部对齐：<br>
				&nbsp;设置类.innerdiv1和类.innerdiv2的style属性vertical-align为bottom，<br>
				效果如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<img src="{{site.baseurl}}/img/2015-12-17/vertical-bottom.png">
			</div>
		</div>
	</div>

	<div class="post-content-block-1 post-content-vmargin-1">
		<div class="post-content-title-1">inline-block的间距设置为0</div>
		
		<div class="post-content-block-2">	
			<div class="post-content-title-2">1.父容器的padding设置成0</div>
			<div class="post-content-body-default">
				<pre>
.outerdiv{
    padding:0;
}
				</pre>
			</div>

			<div class="post-content-title-2 post-content-vmargin-2">2.子容器的margin设置成0</div>
			<div class="post-content-body-default">
				<pre>
.innerdiv1,innerdiv2{
    display: inline-block;
    vertical-align: top;
    margin: 0
}
				</pre>
			</div>

			<div class="post-content-title-2 post-content-vmargin-2">3.最关键的一步：设置父容器的font-size为0</div>
			<div class="post-content-body-default">
				这一步尤为关键，若父容器的font-size不为0，则子容器之间的间距也不等于0.
				<pre>
.outerdiv{
    font-size:0;
}
.innerdiv1,innerdiv2{
    font-size:14px;
}
				</pre>
				效果如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<img src="{{site.baseurl}}/img/2015-12-17/clear-distance.png">			
			</div>
		</div>
	</div>

</div>


